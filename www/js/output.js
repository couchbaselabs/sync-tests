(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/coax/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/coax\"}\n//@ sourceURL=/node_modules/coax/package.json"
));

require.define("/node_modules/coax/lib/coax.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * coax\n * https://github.com/jchris/coax\n *\n * Copyright (c) 2013 Chris Anderson\n * Licensed under the Apache license.\n */\nvar pax = require(\"pax\"),\n  hoax = require(\"hoax\");\n\nvar coaxPax = pax();\n\ncoaxPax.extend(\"getQuery\", function(params) {\n  params = JSON.parse(JSON.stringify(params));\n  var key, keys = [\"key\", \"startkey\", \"endkey\", \"start_key\", \"end_key\"];\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    if (params[key]) {\n      params[key] = JSON.stringify(params[key]);\n    }\n  }\n  return params;\n});\n\nvar Coax = module.exports = hoax.makeHoax(coaxPax());\n\nCoax.extend(\"changes\", function(opts, cb) {\n  if (typeof opts === \"function\") {\n    cb = opts;\n    opts = {};\n  }\n  var self = this;\n  opts = opts || {};\n  opts.feed = \"longpoll\";\n  opts.since = opts.since || 0;\n  // console.log(\"change opts \"+JSON.stringify(opts));\n  self([\"_changes\", opts], function(err, ok) {\n    if (err && err.code == \"ETIMEDOUT\") {\n      return self.changes(opts, cb); // TODO retry limit?\n    } else if (err) {\n      return cb(err);\n    }\n    ok.results.forEach(function(row){\n      cb(null, row);\n    });\n    opts.since = ok.last_seq + 1;\n    self.changes(opts, cb);\n  });\n});\n\nCoax.extend(\"forceSave\", function(doc, cb) {\n  var api = this(doc._id);\n  api.get(function(err, old) {\n    if (err && err.error !== \"not_found\") {\n      return cb(err);\n    }\n    if (!err) {\n      doc._rev = old._rev;\n    }\n    api.put(doc, cb);\n  });\n});\n\n//@ sourceURL=/node_modules/coax/lib/coax.js"
));

require.define("/node_modules/coax/node_modules/pax/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/pax\"}\n//@ sourceURL=/node_modules/coax/node_modules/pax/package.json"
));

require.define("/node_modules/coax/node_modules/pax/lib/pax.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * pax\n * https://github.com/jchris/pax\n *\n * Copyright (c) 2013 Chris Anderson\n * Licensed under the APL license.\n */\n\nfunction objToQuery(q) {\n  var k, ks = Object.keys(q), v, query = [];\n  for (k = 0; k < ks.length; k++) {\n    v = q[ks[k]];\n    query.push(encodeURIComponent(ks[k])+'='+encodeURIComponent(v.toString()));\n  }\n  return query.join('&');\n}\n\n// if there is an object in the new path,\n// pluck it out and put it on the pax instance;\n\nfunction processPath(path) {\n  var query;\n  if (path && path.pop && path.length) {\n    if (typeof path[path.length-1] === 'object') {\n      path.query = path.pop();\n    }\n    return path;\n  } else if (typeof path === \"object\") { // options\n    var empty = [];\n    empty.query = path;\n    return empty;\n  } else if (path) { // string\n    return [path];\n  } else {\n    return [];\n  }\n}\n\nfunction merge(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction mergePaths(path, newPath) {\n  var k, merged = path.concat(newPath);\n  merged.methods = {};\n  if (path.query)  {\n    merged.query = merge({}, path.query);\n  }\n  if (newPath.query) {\n    merged.query = merge(merged.query || {}, newPath.query);\n  }\n  if (typeof path.getQuery !== 'undefined') {\n    merged.getQuery = path.getQuery;\n  }\n  for (k in path.methods) {\n    merged.methods[k] = path.methods[k];\n  }\n\n  // if (typeof newPath.getQuery !== 'undefined') {\n  //   merged.getQuery = newPath.getQuery;\n  // }\n  return merged;\n}\n\nfunction makeToString(path) {\n  var first = true,\n  encoded = path.map(function(p) {\n    if (first) {\n      first = false;\n      if (/^http/.test(p)) {\n        if (/\\/$/.test(p)) {\n          return p.substring(0,p.length-1);\n        } else {\n          return p;\n        }\n      }\n    }\n    return encodeURIComponent(p);\n  });\n\n  return function() {\n    if (path.query) {\n      var qobj;\n      if (path.getQuery || this.getQuery) {\n        qobj = (path.getQuery || this.getQuery)(path.query);\n      } else {\n        qobj = path.query;\n      }\n      return encoded.join('/') + '?' + objToQuery(qobj);\n    } else {\n      return encoded.join('/');\n    }\n  };\n}\n\nfunction extenderizer(path) {\n  path.methods = path.methods || {};\n  return function(name, fun) {\n    path.methods[name] = fun;\n    this[name] = fun;\n  };\n}\n\nfunction addExtensions(pax, path) {\n  var k;\n  for (k in path.methods) {\n    pax[k] = path.methods[k];\n  }\n}\n\nvar growPax;\n\nfunction makeNextPathFun(path) {\n  var nextPax = function(nextPath) {\n    // console.log(\"nextPax\",nextPax);\n    if (typeof nextPax.getQuery !== 'undefined') {path.getQuery = nextPax.getQuery;}\n    if (arguments.length > 1) {\n      return growPax(path, [].map.call(arguments,function(arg){return arg;}));\n    } else {\n      return growPax(path, nextPath);\n    }\n  };\n  addExtensions(nextPax, path);\n  nextPax.extend = extenderizer(path);\n  // console.log([\"pax\", path, path.query]);\n  nextPax.toString = makeToString(path);\n  // console.log([\"paxs\", nextPax.toString()]);\n  return nextPax;\n}\n\nfunction growPax(path, newPath) {\n  newPath = processPath(newPath);\n  path = mergePaths(path, newPath);\n  return makeNextPathFun(path);\n}\n\nmodule.exports = makeNextPathFun([]);\n\n\n//@ sourceURL=/node_modules/coax/node_modules/pax/lib/pax.js"
));

require.define("/node_modules/coax/node_modules/hoax/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/hoax\",\"browserify\":\"lib/hoax-browserify\"}\n//@ sourceURL=/node_modules/coax/node_modules/hoax/package.json"
));

require.define("/node_modules/coax/node_modules/hoax/lib/hoax-browserify.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var core = require(\"./hoax-core\"),\n  request = require(\"browser-request\");\n\nrequest.log.debug = function() {};\n\nmodule.exports = core(request);\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/lib/hoax-browserify.js"
));

require.define("/node_modules/coax/node_modules/hoax/lib/hoax-core.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * hoax\n * https://github.com/jchris/hoax\n *\n * Copyright (c) 2013 Chris Anderson\n * Licensed under the Apache license.\n */\n\nmodule.exports = function(request) {\n  var pax = require(\"pax\");\n\n  function makeHoaxCallback(cb, verb) {\n    return function(err, res, body){\n      // console.log(\"hoax cb\", verb||\"get\", err, res.statusCode, body);\n      if (err && err !== \"error\") {\n        cb(err, res, body);\n      } else {\n        if (res.statusCode >= 400 || err === \"error\") {\n          cb(body || res.statusCode, res);\n        } else {\n          cb(null, body);\n        }\n      }\n    };\n  }\n\n  function processArguments(myPax, urlOrOpts, data, cb, verb) {\n    var opts = {}, newPax = myPax;\n    if (typeof urlOrOpts === 'function') {\n      cb = urlOrOpts;\n      data = null;\n      urlOrOpts = null;\n    } else {\n      if (urlOrOpts.uri || urlOrOpts.url) {\n        newPax = myPax(urlOrOpts.uri || urlOrOpts.url);\n      } else {\n        if (typeof data === 'function') {\n          // we have only 2 args\n          // the first is data if it is not an array\n          // and the verb is put or post\n          cb = data;\n          data = null;\n          if ((verb === \"put\" || verb === \"post\") &&\n            (typeof urlOrOpts !== \"string\" &&\n              Object.prototype.toString.call(urlOrOpts) !== '[object Array]')) {\n              data = urlOrOpts;\n          } else {\n            newPax = myPax(urlOrOpts);\n          }\n        } else {\n          newPax = myPax(urlOrOpts);\n        }\n      }\n    }\n    opts.headers = {'content-type': 'application/json'};\n    opts.json = true;\n    opts.uri = newPax.toString();\n    if (data) {\n      opts.body = JSON.stringify(data);\n    }\n    return [opts, cb, newPax];\n  }\n\n  function extenderizer(oldHoax) {\n    return function(name, fun) {\n      this.methods = this.methods || {};\n      this.methods[name] = fun;\n      this[name] = fun;\n    };\n  }\n\n  function addExtensions(newHoax, oldHoax) {\n    if (oldHoax && oldHoax.methods) {\n      var k;\n      for (k in oldHoax.methods) {\n        newHoax[k] = oldHoax.methods[k];\n      }\n    }\n  }\n\n  function makeHoax(myPax, verb, oldHoax) {\n    var newHoax = function(opts, data, xcb) {\n      var args = processArguments(myPax, opts, data, xcb, verb),\n        reqOpts = args[0], // includes uri, body\n        cb = args[1],\n        newPax = args[2];\n      if (cb) {\n        // console.log([\"hoax\", verb||\"get\", reqOpts]);\n        if (verb) {\n          return request[verb](reqOpts, makeHoaxCallback(cb, verb));\n        } else {\n          return request(reqOpts, makeHoaxCallback(cb));\n        }\n      } else {\n        // console.log(\"new hoax\", newPax);\n        return makeHoax(newPax, verb, newHoax);\n      }\n    };\n    if (!verb) {\n      \"get put post head del\".split(\" \").forEach(function(v){\n        newHoax[v] = makeHoax(myPax, v, newHoax);\n      });\n    }\n    addExtensions(newHoax, oldHoax);\n    // should this be extenderizer(newHoax) ?\n    newHoax.extend = extenderizer(oldHoax);\n    newHoax.pax = myPax;\n    return newHoax;\n  }\n\n  var Hoax = makeHoax(pax());\n  Hoax.makeHoax = makeHoax;\n\n  return Hoax;\n};\n\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/lib/hoax-core.js"
));

require.define("/node_modules/coax/node_modules/hoax/node_modules/browser-request/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./dist/ender/request.js\"}\n//@ sourceURL=/node_modules/coax/node_modules/hoax/node_modules/browser-request/package.json"
));

require.define("/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/request.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Browser Request\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar xmlhttprequest = require('./xmlhttprequest')\nif(!xmlhttprequest || typeof xmlhttprequest !== 'object')\n  throw new Error('Could not find ./xmlhttprequest')\n\nvar XHR = xmlhttprequest.XMLHttpRequest\nif(!XHR)\n  throw new Error('Bad xmlhttprequest.XMLHttpRequest')\nif(! ('_object' in (new XHR)))\n  throw new Error('This is not portable XMLHttpRequest')\n\nmodule.exports = request\nrequest.XMLHttpRequest = XHR\nrequest.log = getLogger()\n\nvar DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes\n\n//\n// request\n//\n\nfunction request(options, callback) {\n  // The entry-point to the API: prep the options object and pass the real work to run_xhr.\n  if(typeof callback !== 'function')\n    throw new Error('Bad callback given: ' + callback)\n\n  if(!options)\n    throw new Error('No options given')\n\n  var options_onResponse = options.onResponse; // Save this for later.\n\n  if(typeof options === 'string')\n    options = {'uri':options};\n  else\n    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.\n\n  options.onResponse = options_onResponse // And put it back.\n\n  if(options.url) {\n    options.uri = options.url;\n    delete options.url;\n  }\n\n  if(!options.uri && options.uri !== \"\")\n    throw new Error(\"options.uri is a required argument\");\n\n  if(typeof options.uri != \"string\")\n    throw new Error(\"options.uri must be a string\");\n\n  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']\n  for (var i = 0; i < unsupported_options.length; i++)\n    if(options[ unsupported_options[i] ])\n      throw new Error(\"options.\" + unsupported_options[i] + \" is not supported\")\n\n  options.callback = callback\n  options.method = options.method || 'GET';\n  options.headers = options.headers || {};\n  options.body    = options.body || null\n  options.timeout = options.timeout || request.DEFAULT_TIMEOUT\n\n  if(options.headers.host)\n    throw new Error(\"Options.headers.host is not supported\");\n\n  if(options.json) {\n    options.headers.accept = options.headers.accept || 'application/json'\n    if(options.method !== 'GET')\n      options.headers['content-type'] = 'application/json'\n\n    if(typeof options.json !== 'boolean')\n      options.body = JSON.stringify(options.json)\n    else if(typeof options.body !== 'string')\n      options.body = JSON.stringify(options.body)\n  }\n\n  // If onResponse is boolean true, call back immediately when the response is known,\n  // not when the full request is complete.\n  options.onResponse = options.onResponse || noop\n  if(options.onResponse === true) {\n    options.onResponse = callback\n    options.callback = noop\n  }\n\n  // XXX Browsers do not like this.\n  //if(options.body)\n  //  options.headers['content-length'] = options.body.length;\n\n  // HTTP basic authentication\n  if(!options.headers.authorization && options.auth)\n    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);\n\n  return run_xhr(options)\n}\n\nvar req_seq = 0\nfunction run_xhr(options) {\n  var xhr = new XHR\n    , timed_out = false\n    , is_cors = is_crossDomain(options.uri)\n    , supports_cors = ('withCredentials' in xhr._object)\n\n  req_seq += 1\n  xhr.seq_id = req_seq\n  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri\n  xhr._id = xhr.id // I know I will type \"_id\" from habit all the time.\n\n  if(is_cors && !supports_cors) {\n    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)\n    cors_err.cors = 'unsupported'\n    return options.callback(cors_err, xhr)\n  }\n\n  xhr.timeoutTimer = setTimeout(too_late, options.timeout)\n  function too_late() {\n    timed_out = true\n    var er = new Error('ETIMEDOUT')\n    er.code = 'ETIMEDOUT'\n    er.duration = options.timeout\n\n    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })\n    return options.callback(er, xhr)\n  }\n\n  // Some states can be skipped over, so remember what is still incomplete.\n  var did = {'response':false, 'loading':false, 'end':false}\n\n  xhr.onreadystatechange = on_state_change\n  xhr.open(options.method, options.uri, true) // asynchronous\n  if(is_cors)\n    xhr._object.withCredentials = !! options.withCredentials\n  xhr.send(options.body)\n  return xhr\n\n  function on_state_change(event) {\n    if(timed_out)\n      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})\n\n    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})\n\n    if(xhr.readyState === XHR.OPENED) {\n      request.log.debug('Request started', {'id':xhr.id})\n      for (var key in options.headers)\n        xhr.setRequestHeader(key, options.headers[key])\n    }\n\n    else if(xhr.readyState === XHR.HEADERS_RECEIVED)\n      on_response()\n\n    else if(xhr.readyState === XHR.LOADING) {\n      on_response()\n      on_loading()\n    }\n\n    else if(xhr.readyState === XHR.DONE) {\n      on_response()\n      on_loading()\n      on_end()\n    }\n  }\n\n  function on_response() {\n    if(did.response)\n      return\n\n    did.response = true\n    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})\n    clearTimeout(xhr.timeoutTimer)\n    xhr.statusCode = xhr.status // Node request compatibility\n\n    // Detect failed CORS requests.\n    if(is_cors && xhr.statusCode == 0) {\n      var cors_err = new Error('CORS request rejected: ' + options.uri)\n      cors_err.cors = 'rejected'\n\n      // Do not process this request further.\n      did.loading = true\n      did.end = true\n\n      return options.callback(cors_err, xhr)\n    }\n\n    options.onResponse(null, xhr)\n  }\n\n  function on_loading() {\n    if(did.loading)\n      return\n\n    did.loading = true\n    request.log.debug('Response body loading', {'id':xhr.id})\n    // TODO: Maybe simulate \"data\" events by watching xhr.responseText\n  }\n\n  function on_end() {\n    if(did.end)\n      return\n\n    did.end = true\n    request.log.debug('Request done', {'id':xhr.id})\n\n    xhr.body = xhr.responseText\n    if(options.json) {\n      try        { xhr.body = JSON.parse(xhr.responseText) }\n      catch (er) { return options.callback(er, xhr)        }\n    }\n\n    options.callback(null, xhr, xhr.body)\n  }\n\n} // request\n\nrequest.withCredentials = false;\nrequest.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\n\n//\n// HTTP method shortcuts\n//\n\nvar shortcuts = [ 'get', 'put', 'post', 'head' ];\nshortcuts.forEach(function(shortcut) {\n  var method = shortcut.toUpperCase();\n  var func   = shortcut.toLowerCase();\n\n  request[func] = function(opts) {\n    if(typeof opts === 'string')\n      opts = {'method':method, 'uri':opts};\n    else {\n      opts = JSON.parse(JSON.stringify(opts));\n      opts.method = method;\n    }\n\n    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));\n    return request.apply(this, args);\n  }\n})\n\n//\n// CouchDB shortcut\n//\n\nrequest.couch = function(options, callback) {\n  if(typeof options === 'string')\n    options = {'uri':options}\n\n  // Just use the request API to do JSON.\n  options.json = true\n  if(options.body)\n    options.json = options.body\n  delete options.body\n\n  callback = callback || noop\n\n  var xhr = request(options, couch_handler)\n  return xhr\n\n  function couch_handler(er, resp, body) {\n    if(er)\n      return callback(er, resp, body)\n\n    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {\n      // The body is a Couch JSON object indicating the error.\n      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))\n      for (var key in body)\n        er[key] = body[key]\n      return callback(er, resp, body);\n    }\n\n    return callback(er, resp, body);\n  }\n}\n\n//\n// Utility\n//\n\nfunction noop() {}\n\nfunction getLogger() {\n  var logger = {}\n    , levels = ['trace', 'debug', 'info', 'warn', 'error']\n    , level, i\n\n  for(i = 0; i < levels.length; i++) {\n    level = levels[i]\n\n    logger[level] = noop\n    if(typeof console !== 'undefined' && console && console[level])\n      logger[level] = formatted(console, level)\n  }\n\n  return logger\n}\n\nfunction formatted(obj, method) {\n  return formatted_logger\n\n  function formatted_logger(str, context) {\n    if(typeof context === 'object')\n      str += ' ' + JSON.stringify(context)\n\n    return obj[method].call(obj, str)\n  }\n}\n\n// Return whether a URL is a cross-domain request.\nfunction is_crossDomain(url) {\n  var rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/\n\n  // jQuery #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n  var ajaxLocation\n  try { ajaxLocation = location.href }\n  catch (e) {\n    // Use the href attribute of an A element since IE will modify it given document.location\n    ajaxLocation = document.createElement( \"a\" );\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  }\n\n  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []\n    , parts = rurl.exec(url.toLowerCase() )\n\n  var result = !!(\n    parts &&\n    (  parts[1] != ajaxLocParts[1]\n    || parts[2] != ajaxLocParts[2]\n    || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))\n    )\n  )\n\n  //console.debug('is_crossDomain('+url+') -> ' + result)\n  return result\n}\n\n// MIT License from http://phpjs.org/functions/base64_encode:358\nfunction b64_enc (data) {\n    // Encodes string using MIME base64 algorithm\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc=\"\", tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    // assume utf8 data\n    // data = this.utf8_encode(data+'');\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n        break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n        break;\n    }\n\n    return enc;\n}\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/request.js"
));

require.define("/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/xmlhttprequest.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n\n!function(window) {\n  if(typeof exports === 'undefined')\n    throw new Error('Cannot find global \"exports\" object. Is this really CommonJS?')\n  if(typeof module === 'undefined')\n    throw new Error('Cannot find global \"module\" object. Is this really CommonJS?')\n  if(!module.exports)\n    throw new Error('Cannot find global \"module.exports\" object. Is this really CommonJS?')\n\n  // Define globals to simulate a browser environment.\n  window = window || {}\n\n  var document = window.document || {}\n  if(!window.document)\n    window.document = document\n\n  var navigator = window.navigator || {}\n  if(!window.navigator)\n    window.navigator = navigator\n\n  if(!navigator.userAgent)\n    navigator.userAgent = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22';\n\n  // Remember the old values in window. If the inner code changes anything, export that as a module and restore the old window value.\n  var win = {}\n    , key\n\n  for (key in window)\n    if(window.hasOwnProperty(key))\n      win[key] = window[key]\n\n  run_code()\n\n  for (key in window)\n    if(window.hasOwnProperty(key))\n      if(window[key] !== win[key]) {\n        exports[key] = window[key]\n        window[key] = win[key]\n      }\n\n  function run_code() {\n    // Begin browser file: XMLHttpRequest.js\n/**\n* XMLHttpRequest.js Copyright (C) 2011 Sergey Ilinsky (http://www.ilinsky.com)\n*\n* This work is free software; you can redistribute it and/or modify\n* it under the terms of the GNU Lesser General Public License as published by\n* the Free Software Foundation; either version 2.1 of the License, or\n* (at your option) any later version.\n*\n* This work is distributed in the hope that it will be useful,\n* but without any warranty; without even the implied warranty of\n* merchantability or fitness for a particular purpose. See the\n* GNU Lesser General Public License for more details.\n*\n* You should have received a copy of the GNU Lesser General Public License\n* along with this library; if not, write to the Free Software Foundation, Inc.,\n* 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n(function () {\n\n\t// Save reference to earlier defined object implementation (if any)\n\tvar oXMLHttpRequest = window.XMLHttpRequest;\n\n\t// Define on browser type\n\tvar bGecko  = !!window.controllers;\n\tvar bIE     = !!window.document.namespaces;\n\tvar bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);\n\n\t// Enables \"XMLHttpRequest()\" call next to \"new XMLHttpRequest()\"\n\tfunction fXMLHttpRequest() {\n\t\tthis._object  = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n\t\tthis._listeners = [];\n\t}\n\n\t// Constructor\n\tfunction cXMLHttpRequest() {\n\t\treturn new fXMLHttpRequest;\n\t}\n\tcXMLHttpRequest.prototype = fXMLHttpRequest.prototype;\n\n\t// BUGFIX: Firefox with Firebug installed would break pages if not executed\n\tif (bGecko && oXMLHttpRequest.wrapped) {\n\t\tcXMLHttpRequest.wrapped = oXMLHttpRequest.wrapped;\n\t}\n\n\t// Constants\n\tcXMLHttpRequest.UNSENT            = 0;\n\tcXMLHttpRequest.OPENED            = 1;\n\tcXMLHttpRequest.HEADERS_RECEIVED  = 2;\n\tcXMLHttpRequest.LOADING           = 3;\n\tcXMLHttpRequest.DONE              = 4;\n\n\t// Interface level constants\n\tcXMLHttpRequest.prototype.UNSENT            = cXMLHttpRequest.UNSENT;\n\tcXMLHttpRequest.prototype.OPENED            = cXMLHttpRequest.OPENED;\n\tcXMLHttpRequest.prototype.HEADERS_RECEIVED  = cXMLHttpRequest.HEADERS_RECEIVED;\n\tcXMLHttpRequest.prototype.LOADING           = cXMLHttpRequest.LOADING;\n\tcXMLHttpRequest.prototype.DONE              = cXMLHttpRequest.DONE;\n\n\t// Public Properties\n\tcXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;\n\tcXMLHttpRequest.prototype.responseText  = '';\n\tcXMLHttpRequest.prototype.responseXML   = null;\n\tcXMLHttpRequest.prototype.status        = 0;\n\tcXMLHttpRequest.prototype.statusText    = '';\n\n\t// Priority proposal\n\tcXMLHttpRequest.prototype.priority    = \"NORMAL\";\n\n\t// Instance-level Events Handlers\n\tcXMLHttpRequest.prototype.onreadystatechange  = null;\n\n\t// Class-level Events Handlers\n\tcXMLHttpRequest.onreadystatechange  = null;\n\tcXMLHttpRequest.onopen              = null;\n\tcXMLHttpRequest.onsend              = null;\n\tcXMLHttpRequest.onabort             = null;\n\n\t// Public Methods\n\tcXMLHttpRequest.prototype.open  = function(sMethod, sUrl, bAsync, sUser, sPassword) {\n\t\t// http://www.w3.org/TR/XMLHttpRequest/#the-open-method\n\t\tvar sLowerCaseMethod = sMethod.toLowerCase();\n\t\tif (sLowerCaseMethod == \"connect\" || sLowerCaseMethod == \"trace\" || sLowerCaseMethod == \"track\") {\n\t\t\t// Using a generic error and an int - not too sure all browsers support correctly\n\t\t\t// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#securityerror, so, this is safer\n\t\t\t// XXX should do better than that, but this is OT to XHR.\n\t\t\tthrow new Error(18);\n\t\t}\n\n\t\t// Delete headers, required when object is reused\n\t\tdelete this._headers;\n\n\t\t// When bAsync parameter value is omitted, use true as default\n\t\tif (arguments.length < 3) {\n\t\t\tbAsync  = true;\n\t\t}\n\n\t\t// Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests\n\t\tthis._async   = bAsync;\n\n\t\t// Set the onreadystatechange handler\n\t\tvar oRequest  = this;\n\t\tvar nState    = this.readyState;\n\t\tvar fOnUnload = null;\n\n\t\t// BUGFIX: IE - memory leak on page unload (inter-page leak)\n\t\tif (bIE && bAsync) {\n\t\t\tfOnUnload = function() {\n\t\t\t\tif (nState != cXMLHttpRequest.DONE) {\n\t\t\t\t\tfCleanTransport(oRequest);\n\t\t\t\t\t// Safe to abort here since onreadystatechange handler removed\n\t\t\t\t\toRequest.abort();\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.attachEvent(\"onunload\", fOnUnload);\n\t\t}\n\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onopen) {\n\t\t\tcXMLHttpRequest.onopen.apply(this, arguments);\n\t\t}\n\n\t\tif (arguments.length > 4) {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync, sUser, sPassword);\n\t\t} else if (arguments.length > 3) {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync, sUser);\n\t\t} else {\n\t\t\tthis._object.open(sMethod, sUrl, bAsync);\n\t\t}\n\n\t\tthis.readyState = cXMLHttpRequest.OPENED;\n\t\tfReadyStateChange(this);\n\n\t\tthis._object.onreadystatechange = function() {\n\t\t\tif (bGecko && !bAsync) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Synchronize state\n\t\t\toRequest.readyState   = oRequest._object.readyState;\n\t\t\tfSynchronizeValues(oRequest);\n\n\t\t\t// BUGFIX: Firefox fires unnecessary DONE when aborting\n\t\t\tif (oRequest._aborted) {\n\t\t\t\t// Reset readyState to UNSENT\n\t\t\t\toRequest.readyState = cXMLHttpRequest.UNSENT;\n\n\t\t\t\t// Return now\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (oRequest.readyState == cXMLHttpRequest.DONE) {\n\t\t\t\t// Free up queue\n\t\t\t\tdelete oRequest._data;\n\n\t\t\t\t// Uncomment these lines for bAsync\n\t\t\t\t/**\n\t\t\t\t * if (bAsync) {\n\t\t\t\t * \tfQueue_remove(oRequest);\n\t\t\t\t * }\n\t\t\t\t */\n\n\t\t\t\tfCleanTransport(oRequest);\n\n\t\t\t\t// Uncomment this block if you need a fix for IE cache\n\t\t\t\t/**\n\t\t\t\t * // BUGFIX: IE - cache issue\n\t\t\t\t * if (!oRequest._object.getResponseHeader(\"Date\")) {\n\t\t\t\t * \t// Save object to cache\n\t\t\t\t * \toRequest._cached  = oRequest._object;\n\t\t\t\t *\n\t\t\t\t * \t// Instantiate a new transport object\n\t\t\t\t * \tcXMLHttpRequest.call(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t// Re-send request\n\t\t\t\t * \tif (sUser) {\n\t\t\t\t * \t\tif (sPassword) {\n\t\t\t\t * \t\t\toRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);\n\t\t\t\t * \t\t} else {\n\t\t\t\t * \t\t\toRequest._object.open(sMethod, sUrl, bAsync);\n\t\t\t\t * \t\t}\n\t\t\t\t *\n\t\t\t\t * \t\toRequest._object.setRequestHeader(\"If-Modified-Since\", oRequest._cached.getResponseHeader(\"Last-Modified\") || new window.Date(0));\n\t\t\t\t * \t\t// Copy headers set\n\t\t\t\t * \t\tif (oRequest._headers) {\n\t\t\t\t * \t\t\tfor (var sHeader in oRequest._headers) {\n\t\t\t\t * \t\t\t\t// Some frameworks prototype objects with functions\n\t\t\t\t * \t\t\t\tif (typeof oRequest._headers[sHeader] == \"string\") {\n\t\t\t\t * \t\t\t\t\toRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t * \t\t\t}\n\t\t\t\t * \t\t}\n\t\t\t\t * \t\toRequest._object.onreadystatechange = function() {\n\t\t\t\t * \t\t\t// Synchronize state\n\t\t\t\t * \t\t\toRequest.readyState   = oRequest._object.readyState;\n\t\t\t\t *\n\t\t\t\t * \t\t\tif (oRequest._aborted) {\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\toRequest.readyState = cXMLHttpRequest.UNSENT;\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// Return\n\t\t\t\t * \t\t\t\treturn;\n\t\t\t\t * \t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\tif (oRequest.readyState == cXMLHttpRequest.DONE) {\n\t\t\t\t * \t\t\t\t// Clean Object\n\t\t\t\t * \t\t\t\tfCleanTransport(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// get cached request\n\t\t\t\t * \t\t\t\tif (oRequest.status == 304) {\n\t\t\t\t * \t\t\t\t\toRequest._object  = oRequest._cached;\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tdelete oRequest._cached;\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tfSynchronizeValues(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t//\n\t\t\t\t * \t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t *\n\t\t\t\t * \t\t\t\t// BUGFIX: IE - memory leak in interrupted\n\t\t\t\t * \t\t\t\tif (bIE && bAsync) {\n\t\t\t\t * \t\t\t\t\twindow.detachEvent(\"onunload\", fOnUnload);\n\t\t\t\t * \t\t\t\t}\n\t\t\t\t *\n\t\t\t\t * \t\t\t}\n\t\t\t\t * \t\t};\n\t\t\t\t * \t\toRequest._object.send(null);\n\t\t\t\t *\n\t\t\t\t * \t\t// Return now - wait until re-sent request is finished\n\t\t\t\t * \t\treturn;\n\t\t\t\t * \t};\n\t\t\t\t */\n\n\t\t\t\t// BUGFIX: IE - memory leak in interrupted\n\t\t\t\tif (bIE && bAsync) {\n\t\t\t\t\twindow.detachEvent(\"onunload\", fOnUnload);\n\t\t\t\t}\n\n\t\t\t\t// BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice\n\t\t\t\tif (nState != oRequest.readyState) {\n\t\t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t}\n\n\t\t\t\tnState  = oRequest.readyState;\n\t\t\t}\n\t\t};\n\t};\n\n\tcXMLHttpRequest.prototype.send = function(vData) {\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onsend) {\n\t\t\tcXMLHttpRequest.onsend.apply(this, arguments);\n\t\t}\n\n\t\tif (!arguments.length) {\n\t\t\tvData = null;\n\t\t}\n\n\t\t// BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required\n\t\t// BUGFIX: IE - rewrites any custom mime-type to \"text/xml\" in case an XMLNode is sent\n\t\t// BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)\n\t\tif (vData && vData.nodeType) {\n\t\t\tvData = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;\n\t\t\tif (!this._headers[\"Content-Type\"]) {\n\t\t\t\tthis._object.setRequestHeader(\"Content-Type\", \"application/xml\");\n\t\t\t}\n\t\t}\n\n\t\tthis._data = vData;\n\n\t\t/**\n\t\t * // Add to queue\n\t\t * if (this._async) {\n\t\t * \tfQueue_add(this);\n\t\t * } else { */\n\t\tfXMLHttpRequest_send(this);\n\t\t /**\n\t\t * }\n\t\t */\n\t};\n\n\tcXMLHttpRequest.prototype.abort = function() {\n\t\t// Add method sniffer\n\t\tif (cXMLHttpRequest.onabort) {\n\t\t\tcXMLHttpRequest.onabort.apply(this, arguments);\n\t\t}\n\n\t\t// BUGFIX: Gecko - unnecessary DONE when aborting\n\t\tif (this.readyState > cXMLHttpRequest.UNSENT) {\n\t\t\tthis._aborted = true;\n\t\t}\n\n\t\tthis._object.abort();\n\n\t\t// BUGFIX: IE - memory leak\n\t\tfCleanTransport(this);\n\n\t\tthis.readyState = cXMLHttpRequest.UNSENT;\n\n\t\tdelete this._data;\n\n\t\t/* if (this._async) {\n\t \t* \tfQueue_remove(this);\n\t \t* }\n\t \t*/\n\t};\n\n\tcXMLHttpRequest.prototype.getAllResponseHeaders = function() {\n\t\treturn this._object.getAllResponseHeaders();\n\t};\n\n\tcXMLHttpRequest.prototype.getResponseHeader = function(sName) {\n\t\treturn this._object.getResponseHeader(sName);\n\t};\n\n\tcXMLHttpRequest.prototype.setRequestHeader  = function(sName, sValue) {\n\t\t// BUGFIX: IE - cache issue\n\t\tif (!this._headers) {\n\t\t\tthis._headers = {};\n\t\t}\n\n\t\tthis._headers[sName]  = sValue;\n\n\t\treturn this._object.setRequestHeader(sName, sValue);\n\t};\n\n\t// EventTarget interface implementation\n\tcXMLHttpRequest.prototype.addEventListener  = function(sName, fHandler, bUseCapture) {\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Add listener\n\t\tthis._listeners.push([sName, fHandler, bUseCapture]);\n\t};\n\n\tcXMLHttpRequest.prototype.removeEventListener = function(sName, fHandler, bUseCapture) {\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Remove listener\n\t\tif (oListener) {\n\t\t\tthis._listeners.splice(nIndex, 1);\n\t\t}\n\t};\n\n\tcXMLHttpRequest.prototype.dispatchEvent = function(oEvent) {\n\t\tvar oEventPseudo  = {\n\t\t\t'type':             oEvent.type,\n\t\t\t'target':           this,\n\t\t\t'currentTarget':    this,\n\t\t\t'eventPhase':       2,\n\t\t\t'bubbles':          oEvent.bubbles,\n\t\t\t'cancelable':       oEvent.cancelable,\n\t\t\t'timeStamp':        oEvent.timeStamp,\n\t\t\t'stopPropagation':  function() {},  // There is no flow\n\t\t\t'preventDefault':   function() {},  // There is no default action\n\t\t\t'initEvent':        function() {}   // Original event object should be initialized\n\t\t};\n\n\t\t// Execute onreadystatechange\n\t\tif (oEventPseudo.type == \"readystatechange\" && this.onreadystatechange) {\n\t\t\t(this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);\n\t\t}\n\n\n\t\t// Execute listeners\n\t\tfor (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++) {\n\t\t\tif (oListener[0] == oEventPseudo.type && !oListener[2]) {\n\t\t\t\t(oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);\n\t\t\t}\n\t\t}\n\n\t};\n\n\t//\n\tcXMLHttpRequest.prototype.toString  = function() {\n\t\treturn '[' + \"object\" + ' ' + \"XMLHttpRequest\" + ']';\n\t};\n\n\tcXMLHttpRequest.toString  = function() {\n\t\treturn '[' + \"XMLHttpRequest\" + ']';\n\t};\n\n\t/**\n\t * // Queue manager\n\t * var oQueuePending = {\"CRITICAL\":[],\"HIGH\":[],\"NORMAL\":[],\"LOW\":[],\"LOWEST\":[]},\n\t * aQueueRunning = [];\n\t * function fQueue_add(oRequest) {\n\t * \toQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : \"NORMAL\"].push(oRequest);\n\t * \t//\n\t * \tsetTimeout(fQueue_process);\n\t * };\n\t *\n\t * function fQueue_remove(oRequest) {\n\t * \tfor (var nIndex = 0, bFound = false; nIndex < aQueueRunning.length; nIndex++)\n\t * \tif (bFound) {\n\t * \t\taQueueRunning[nIndex - 1] = aQueueRunning[nIndex];\n\t * \t} else {\n\t * \t\tif (aQueueRunning[nIndex] == oRequest) {\n\t * \t\t\tbFound  = true;\n\t * \t\t}\n\t * }\n\t *\n\t * \tif (bFound) {\n\t * \t\taQueueRunning.length--;\n\t * \t}\n\t *\n\t *\n\t * \t//\n\t * \tsetTimeout(fQueue_process);\n\t * };\n\t *\n\t * function fQueue_process() {\n\t * if (aQueueRunning.length < 6) {\n\t * for (var sPriority in oQueuePending) {\n\t * if (oQueuePending[sPriority].length) {\n\t * var oRequest  = oQueuePending[sPriority][0];\n\t * oQueuePending[sPriority]  = oQueuePending[sPriority].slice(1);\n\t * //\n\t * aQueueRunning.push(oRequest);\n\t * // Send request\n\t * fXMLHttpRequest_send(oRequest);\n\t * break;\n\t * }\n\t * }\n\t * }\n\t * };\n\t */\n\n\t// Helper function\n\tfunction fXMLHttpRequest_send(oRequest) {\n\t\toRequest._object.send(oRequest._data);\n\n\t\t// BUGFIX: Gecko - missing readystatechange calls in synchronous requests\n\t\tif (bGecko && !oRequest._async) {\n\t\t\toRequest.readyState = cXMLHttpRequest.OPENED;\n\n\t\t\t// Synchronize state\n\t\t\tfSynchronizeValues(oRequest);\n\n\t\t\t// Simulate missing states\n\t\t\twhile (oRequest.readyState < cXMLHttpRequest.DONE) {\n\t\t\t\toRequest.readyState++;\n\t\t\t\tfReadyStateChange(oRequest);\n\t\t\t\t// Check if we are aborted\n\t\t\t\tif (oRequest._aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction fReadyStateChange(oRequest) {\n\t\t// Sniffing code\n\t\tif (cXMLHttpRequest.onreadystatechange){\n\t\t\tcXMLHttpRequest.onreadystatechange.apply(oRequest);\n\t\t}\n\n\n\t\t// Fake event\n\t\toRequest.dispatchEvent({\n\t\t\t'type':       \"readystatechange\",\n\t\t\t'bubbles':    false,\n\t\t\t'cancelable': false,\n\t\t\t'timeStamp':  new Date + 0\n\t\t});\n\t}\n\n\tfunction fGetDocument(oRequest) {\n\t\tvar oDocument = oRequest.responseXML;\n\t\tvar sResponse = oRequest.responseText;\n\t\t// Try parsing responseText\n\t\tif (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader(\"Content-Type\").match(/[^\\/]+\\/[^\\+]+\\+xml/)) {\n\t\t\toDocument = new window.ActiveXObject(\"Microsoft.XMLDOM\");\n\t\t\toDocument.async       = false;\n\t\t\toDocument.validateOnParse = false;\n\t\t\toDocument.loadXML(sResponse);\n\t\t}\n\n\t\t// Check if there is no error in document\n\t\tif (oDocument){\n\t\t\tif ((bIE && oDocument.parseError !== 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == \"parsererror\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn oDocument;\n\t}\n\n\tfunction fSynchronizeValues(oRequest) {\n\t\ttry { oRequest.responseText = oRequest._object.responseText;  } catch (e) {}\n\t\ttry { oRequest.responseXML  = fGetDocument(oRequest._object); } catch (e) {}\n\t\ttry { oRequest.status       = oRequest._object.status;        } catch (e) {}\n\t\ttry { oRequest.statusText   = oRequest._object.statusText;    } catch (e) {}\n\t}\n\n\tfunction fCleanTransport(oRequest) {\n\t\t// BUGFIX: IE - memory leak (on-page leak)\n\t\toRequest._object.onreadystatechange = new window.Function;\n\t}\n\n\t// Internet Explorer 5.0 (missing apply)\n\tif (!window.Function.prototype.apply) {\n\t\twindow.Function.prototype.apply = function(oRequest, oArguments) {\n\t\t\tif (!oArguments) {\n\t\t\t\toArguments  = [];\n\t\t\t}\n\t\t\toRequest.__func = this;\n\t\t\toRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);\n\t\t\tdelete oRequest.__func;\n\t\t};\n\t}\n\n\t// Register new object with window\n\twindow.XMLHttpRequest = cXMLHttpRequest;\n\n})();\n\n    // End browser file: XMLHttpRequest.js\n  }\n}(typeof window !== 'undefined' ? window : {});\n\n//@ sourceURL=/node_modules/coax/node_modules/hoax/node_modules/browser-request/dist/ender/xmlhttprequest.js"
));

require.define("/node_modules/tape/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/package.json"
));

require.define("/node_modules/tape/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var createDefaultStream = require('./lib/default_stream');\nvar Test = require('./lib/test');\nvar createResultStream = require('./lib/results');\n\nvar canEmitExit = typeof process !== 'undefined' && process\n    && typeof process.on === 'function'\n;\nvar canExit = typeof process !== 'undefined' && process\n    && typeof process.exit === 'function'\n;\n\nvar nextTick = typeof setImmediate !== 'undefined'\n    ? setImmediate\n    : process.nextTick\n;\n\nexports = module.exports = (function () {\n    var harness;\n    var lazyLoad = function () {\n        if (!harness) harness = createExitHarness();\n\n        return harness.apply(this, arguments);\n    };\n\n    lazyLoad.only = function () {\n        if (!harness) harness = createExitHarness();\n\n        return harness.only.apply(this, arguments);\n    }\n\n    return lazyLoad\n})();\n\nfunction createExitHarness (conf) {\n    if (!conf) conf = {};\n    var harness = createHarness();\n    var stream = harness.createStream();\n    stream.pipe(createDefaultStream());\n    \n    var ended = false;\n    stream.on('end', function () { ended = true });\n    \n    if (conf.exit === false) return harness;\n    if (!canEmitExit || !canExit) return harness;\n    \n    process.on('exit', function (code) {\n        if (!ended) {\n            for (var i = 0; i < harness._tests.length; i++) {\n                var t = harness._tests[i];\n                t._exit();\n            }\n        }\n        process.exit(code || harness._exitCode);\n    });\n    return harness;\n}\n\nexports.createHarness = createHarness;\nexports.Test = Test;\nexports.test = exports; // tap compat\n\nvar exitInterval;\n\nfunction createHarness (conf_) {\n    var results;\n    \n    var test = function (name, conf, cb) {\n        if (!results) {\n            results = createResultStream();\n            results.pause();\n        }\n        \n        var t = new Test(name, conf, cb);\n        test._tests.push(t);\n        \n        (function inspectCode (st) {\n            st.on('test', function sub (st_) {\n                inspectCode(st_);\n            });\n            st.on('result', function (r) {\n                if (!r.ok) test._exitCode = 1\n            });\n        })(t);\n        \n        results.push(t);\n        return t;\n    };\n    \n    test._tests = [];\n    \n    test.createStream = function () {\n        if (!results) results = createResultStream();\n        \n        var _pause = results.pause;\n        var paused = false;\n        results.pause = function () { paused = true };\n        \n        nextTick(function () {\n            if (!paused) results.resume();\n        });\n        return results;\n    };\n    \n    var only = false;\n    test.only = function (name) {\n        if (only) throw new Error('there can only be one only test');\n        results.only(name);\n        only = true;\n        return test.apply(null, arguments);\n    };\n    test._exitCode = 0;\n    \n    return test;\n}\n\n//@ sourceURL=/node_modules/tape/index.js"
));

require.define("/node_modules/tape/lib/default_stream.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\n\nmodule.exports = function () {\n    var out = new Stream;\n    out.writable = true;\n    var buffered = '';\n    \n    out.write = function (buf) {\n        var s = buffered + String(buf);\n        var lines = s.split('\\n');\n        for (var i = 0; i < lines.length - 1; i++) {\n            console.log(lines[i]);\n        }\n        buffered = lines[i];\n    };\n    \n    out.destroy = function () {\n        out.writable = false;\n        out.emit('close');\n    };\n    \n    out.end = function (msg) {\n        if (msg !== undefined) out.write(msg);\n        if (buffered) console.log(buffered);\n        out.writable = false;\n        out.emit('close');\n    };\n    \n    return out;\n};\n\n//@ sourceURL=/node_modules/tape/lib/default_stream.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/tape/lib/test.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar deepEqual = require('deep-equal');\nvar defined = require('defined');\nvar path = require('path');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\nmodule.exports = Test;\n\nvar nextTick = typeof setImmediate !== 'undefined'\n    ? setImmediate\n    : process.nextTick\n;\n\ninherits(Test, EventEmitter);\n\nfunction Test (name_, opts_, cb_) {\n    var self = this;\n    var name = '(anonymous)';\n    var opts = {};\n    var cb;\n    \n    for (var i = 0; i < arguments.length; i++) {\n        switch (typeof arguments[i]) {\n            case 'string':\n                name = arguments[i];\n                break;\n            case 'object':\n                opts = arguments[i] || opts;\n                break;\n            case 'function':\n                cb = arguments[i];\n        }\n    }\n    \n    this.readable = true;\n    this.name = name || '(anonymous)';\n    this.assertCount = 0;\n    this._skip = opts.skip || false;\n    this._plan = undefined;\n    this._cb = cb;\n    this._progeny = [];\n    this._ok = true;\n}\n\nTest.prototype.run = function () {\n    if (this._skip) {\n        return this.end();\n    }\n    this.emit('prerun');\n    try {\n        this._cb(this);\n    }\n    catch (err) {\n        this.error(err);\n        this.end();\n        return;\n    }\n    this.emit('run');\n};\n\nTest.prototype.test = function (name, opts, cb) {\n    var t = new Test(name, opts, cb);\n    this._progeny.push(t);\n    this.emit('test', t);\n};\n\nTest.prototype.comment = function (msg) {\n    this.emit('result', msg.trim().replace(/^#\\s*/, ''));\n};\n\nTest.prototype.plan = function (n) {\n    this._plan = n;\n    this.emit('plan', n);\n};\n\nTest.prototype.end = function () {\n    var self = this;\n    if (this._progeny.length) {\n        var t = this._progeny.shift();\n        t.on('end', function () { self.end() });\n        return;\n    }\n    \n    if (!this.ended) this.emit('end');\n    if (this._plan !== undefined &&\n        !this._planError && this.assertCount !== this._plan) {\n        this._planError = true;\n        this.fail('plan != count', {\n            expected : this._plan,\n            actual : this.assertCount\n        });\n    }\n    this.ended = true;\n};\n\nTest.prototype._exit = function () {\n    if (this._plan !== undefined &&\n        !this._planError && this.assertCount !== this._plan) {\n        this._planError = true;\n        this.fail('plan != count', {\n            expected : this._plan,\n            actual : this.assertCount,\n            exiting : true\n        });\n    }\n    else if (!this.ended) {\n        this.fail('test exited without ending', {\n            exiting: true\n        });\n    }\n};\n\nTest.prototype._assert = function assert (ok, opts) {\n    var self = this;\n    var extra = opts.extra || {};\n    \n    var res = {\n        id : self.assertCount ++,\n        ok : Boolean(ok),\n        skip : defined(extra.skip, opts.skip),\n        name : defined(extra.message, opts.message, '(unnamed assert)'),\n        operator : defined(extra.operator, opts.operator),\n        actual : defined(extra.actual, opts.actual),\n        expected : defined(extra.expected, opts.expected)\n    };\n    this._ok = Boolean(this._ok && ok);\n    \n    if (!ok) {\n        res.error = defined(extra.error, opts.error, new Error(res.name));\n    }\n    \n    var e = new Error('exception');\n    var err = (e.stack || '').split('\\n');\n    var dir = path.dirname(__dirname) + '/';\n    \n    for (var i = 0; i < err.length; i++) {\n        var m = /^\\s*\\bat\\s+(.+)/.exec(err[i]);\n        if (!m) continue;\n        \n        var s = m[1].split(/\\s+/);\n        var filem = /(\\/[^:\\s]+:(\\d+)(?::(\\d+))?)/.exec(s[1]);\n        if (!filem) continue;\n        \n        if (filem[1].slice(0, dir.length) === dir) continue;\n        \n        res.functionName = s[0];\n        res.file = filem[1];\n        res.line = Number(filem[2]);\n        if (filem[3]) res.column = filem[3];\n        \n        res.at = m[1];\n        break;\n    }\n    \n    self.emit('result', res);\n    \n    if (self._plan === self.assertCount && extra.exiting) {\n        if (!self.ended) self.end();\n    }\n    else if (self._plan === self.assertCount) {\n        nextTick(function () {\n            if (!self.ended) self.end();\n        });\n    }\n    \n    if (!self._planError && self.assertCount > self._plan) {\n        self._planError = true;\n        self.fail('plan != count', {\n            expected : self._plan,\n            actual : self.assertCount\n        });\n    }\n};\n\nTest.prototype.fail = function (msg, extra) {\n    this._assert(false, {\n        message : msg,\n        operator : 'fail',\n        extra : extra\n    });\n};\n\nTest.prototype.pass = function (msg, extra) {\n    this._assert(true, {\n        message : msg,\n        operator : 'pass',\n        extra : extra\n    });\n};\n\nTest.prototype.skip = function (msg, extra) {\n    this._assert(true, {\n        message : msg,\n        operator : 'skip',\n        skip : true,\n        extra : extra\n    });\n};\n\nTest.prototype.ok\n= Test.prototype['true']\n= Test.prototype.assert\n= function (value, msg, extra) {\n    this._assert(value, {\n        message : msg,\n        operator : 'ok',\n        expected : true,\n        actual : value,\n        extra : extra\n    });\n};\n\nTest.prototype.notOk\n= Test.prototype['false']\n= Test.prototype.notok\n= function (value, msg, extra) {\n    this._assert(!value, {\n        message : msg,\n        operator : 'notOk',\n        expected : false,\n        actual : value,\n        extra : extra\n    });\n};\n\nTest.prototype.error\n= Test.prototype.ifError\n= Test.prototype.ifErr\n= Test.prototype.iferror\n= function (err, msg, extra) {\n    this._assert(!err, {\n        message : defined(msg, String(err)),\n        operator : 'error',\n        actual : err,\n        extra : extra\n    });\n};\n\nTest.prototype.equal\n= Test.prototype.equals\n= Test.prototype.isEqual\n= Test.prototype.is\n= Test.prototype.strictEqual\n= Test.prototype.strictEquals\n= function (a, b, msg, extra) {\n    this._assert(a === b, {\n        message : defined(msg, 'should be equal'),\n        operator : 'equal',\n        actual : a,\n        expected : b,\n        extra : extra\n    });\n};\n\nTest.prototype.notEqual\n= Test.prototype.notEquals\n= Test.prototype.notStrictEqual\n= Test.prototype.notStrictEquals\n= Test.prototype.isNotEqual\n= Test.prototype.isNot\n= Test.prototype.not\n= Test.prototype.doesNotEqual\n= Test.prototype.isInequal\n= function (a, b, msg, extra) {\n    this._assert(a !== b, {\n        message : defined(msg, 'should not be equal'),\n        operator : 'notEqual',\n        actual : a,\n        notExpected : b,\n        extra : extra\n    });\n};\n\nTest.prototype.deepEqual\n= Test.prototype.deepEquals\n= Test.prototype.isEquivalent\n= Test.prototype.looseEqual\n= Test.prototype.looseEquals\n= Test.prototype.same\n= function (a, b, msg, extra) {\n    this._assert(deepEqual(a, b), {\n        message : defined(msg, 'should be equivalent'),\n        operator : 'deepEqual',\n        actual : a,\n        expected : b,\n        extra : extra\n    });\n};\n\nTest.prototype.notDeepEqual\n= Test.prototype.notEquivalent\n= Test.prototype.notDeeply\n= Test.prototype.notSame\n= Test.prototype.isNotDeepEqual\n= Test.prototype.isNotDeeply\n= Test.prototype.isNotEquivalent\n= Test.prototype.isInequivalent\n= function (a, b, msg, extra) {\n    this._assert(!deepEqual(a, b), {\n        message : defined(msg, 'should not be equivalent'),\n        operator : 'notDeepEqual',\n        actual : a,\n        notExpected : b,\n        extra : extra\n    });\n};\n\nTest.prototype['throws'] = function (fn, expected, msg, extra) {\n    if (typeof expected === 'string') {\n        msg = expected;\n        expected = undefined;\n    }\n    var caught = undefined;\n    try {\n        fn();\n    }\n    catch (err) {\n        caught = { error : err };\n        var message = err.message;\n        delete err.message;\n        err.message = message;\n    }\n\n    var passed = caught;\n\n    if (expected instanceof RegExp) {\n        passed = expected.test(caught && caught.error);\n        expected = String(expected);\n    }\n\n    this._assert(passed, {\n        message : defined(msg, 'should throw'),\n        operator : 'throws',\n        actual : caught && caught.error,\n        expected : expected,\n        error: !passed && caught && caught.error,\n        extra : extra\n    });\n};\n\nTest.prototype.doesNotThrow = function (fn, expected, msg, extra) {\n    if (typeof expected === 'string') {\n        msg = expected;\n        expected = undefined;\n    }\n    var caught = undefined;\n    try {\n        fn();\n    }\n    catch (err) {\n        caught = { error : err };\n    }\n    this._assert(!caught, {\n        message : defined(msg, 'should throw'),\n        operator : 'throws',\n        actual : caught && caught.error,\n        expected : expected,\n        error : caught && caught.error,\n        extra : extra\n    });\n};\n\n// vim: set softtabstop=4 shiftwidth=4:\n\n//@ sourceURL=/node_modules/tape/lib/test.js"
));

require.define("/node_modules/tape/node_modules/deep-equal/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/deep-equal/package.json"
));

require.define("/node_modules/tape/node_modules/deep-equal/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var pSlice = Array.prototype.slice;\nvar Object_keys = typeof Object.keys === 'function'\n    ? Object.keys\n    : function (obj) {\n        var keys = [];\n        for (var key in obj) keys.push(key);\n        return keys;\n    }\n;\n\nvar deepEqual = module.exports = function (actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b);\n  }\n  try {\n    var ka = Object_keys(a),\n        kb = Object_keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n//@ sourceURL=/node_modules/tape/node_modules/deep-equal/index.js"
));

require.define("/node_modules/tape/node_modules/defined/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/defined/package.json"
));

require.define("/node_modules/tape/node_modules/defined/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = function () {\n    for (var i = 0; i < arguments.length; i++) {\n        if (arguments[i] !== undefined) return arguments[i];\n    }\n};\n\n//@ sourceURL=/node_modules/tape/node_modules/defined/index.js"
));

require.define("/node_modules/tape/lib/results.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar json = typeof JSON === 'object' ? JSON : require('jsonify');\nvar through = require('through');\nvar nextTick = typeof setImmediate !== 'undefined'\n    ? setImmediate\n    : process.nextTick\n;\n\nmodule.exports = function () {\n    var output = through();\n    output.pause();\n    output.queue('TAP version 13\\n');\n    \n    var results = new Results(output);\n    output.push = function (t) { results.push(t) };\n    \n    output.only = function (name) {\n        results.only = name;\n    };\n    \n    nextTick(function next () {\n        var t = results.tests.shift();\n        if (!t && results.running) return;\n        if (!t) return results.close();\n        t.run();\n    });\n    \n    return output;\n};\n\nfunction Results (stream) {\n    this.count = 0;\n    this.fail = 0;\n    this.pass = 0;\n    this.stream = stream;\n    this.tests = [];\n    this.running = 0;\n}\n\nResults.prototype.push = function (t, parentT) {\n    var self = this;\n    var write = function (s) { self.stream.queue(s) };\n    t.once('prerun', function () {\n        if (self.only && self.only !== t.name && !parentT) {\n            var nt = self.tests.shift();\n            if (nt) nt.run()\n            else self.close();\n            return;\n        }\n        \n        self.running ++;\n        write('# ' + t.name + '\\n');\n    });\n    if (parentT) {\n        var ix = self.tests.indexOf(parentT);\n        if (ix >= 0) self.tests.splice(ix, 0, t);\n    }\n    else self.tests.push(t);\n    \n    var plan;\n    t.on('plan', function (n) { plan = n });\n    \n    var subtests = 0;\n    \n    t.on('test', function (st) {\n        subtests ++;\n        st.on('end', function () {\n            subtests --;\n            if (subtests === 1) nextTick(function () { st.run() });\n            else if (subtests === 0 && !t.ended) {\n                t.end();\n            }\n        });\n        self.push(st, t);\n        if (subtests === 1) {\n            if (plan === undefined) st.run();\n            else nextTick(function () {\n                st.run();\n            });\n        }\n    });\n    \n    t.on('result', function (res) {\n        if (typeof res === 'string') {\n            write('# ' + res + '\\n');\n            return;\n        }\n        write(encodeResult(res, self.count + 1));\n        self.count ++;\n        \n        if (res.ok) self.pass ++\n        else self.fail ++\n    });\n    \n    t.once('end', function () {\n        if (t._skip) {\n            var nt = self.tests.shift();\n            if (nt) nt.run();\n            else self.close();\n            return;\n        }\n        \n        self.running --;\n        if (subtests !== 0) return;\n        \n        if (self.running === 0 && self.tests.length) {\n            var nt = self.tests.shift();\n            nt.run();\n        }\n        else if (self.running === 0) {\n            self.close();\n        }\n    });\n};\n\nResults.prototype.close = function () {\n    var self = this;\n    if (self.closed) self.stream.emit('error', new Error('ALREADY CLOSED'));\n    self.closed = true;\n    var write = function (s) { self.stream.queue(s) };\n    \n    write('\\n1..' + self.count + '\\n');\n    write('# tests ' + self.count + '\\n');\n    write('# pass  ' + self.pass + '\\n');\n    if (self.fail) write('# fail  ' + self.fail + '\\n')\n    else write('\\n# ok\\n')\n    \n    self.stream.queue(null);\n};\n\nfunction encodeResult (res, count) {\n    var output = '';\n    output += (res.ok ? 'ok ' : 'not ok ') + count;\n    output += res.name ? ' ' + res.name.replace(/\\s+/g, ' ') : '';\n    \n    if (res.skip) output += ' # SKIP';\n    else if (res.todo) output += ' # TODO';\n    \n    output += '\\n';\n    if (res.ok) return output;\n    \n    var outer = '  ';\n    var inner = outer + '  ';\n    output += outer + '---\\n';\n    output += inner + 'operator: ' + res.operator + '\\n';\n    \n    var ex = json.stringify(res.expected, getSerialize()) || '';\n    var ac = json.stringify(res.actual, getSerialize()) || '';\n    \n    if (Math.max(ex.length, ac.length) > 65) {\n        output += inner + 'expected:\\n' + inner + '  ' + ex + '\\n';\n        output += inner + 'actual:\\n' + inner + '  ' + ac + '\\n';\n    }\n    else {\n        output += inner + 'expected: ' + ex + '\\n';\n        output += inner + 'actual:   ' + ac + '\\n';\n    }\n    if (res.at) {\n        output += inner + 'at: ' + res.at + '\\n';\n    }\n    if (res.operator === 'error' && res.actual && res.actual.stack) {\n        var lines = String(res.actual.stack).split('\\n');\n        output += inner + 'stack:\\n';\n        output += inner + '  ' + lines[0] + '\\n';\n        for (var i = 1; i < lines.length; i++) {\n            output += inner + lines[i] + '\\n';\n        }\n    }\n    \n    output += outer + '...\\n';\n    return output;\n}\n\nfunction getSerialize () {\n    var seen = [];\n    \n    return function (key, value) {\n        var ret = value;\n        if (typeof value === 'object' && value) {\n            var found = false;\n            for (var i = 0; i < seen.length; i++) {\n                if (seen[i] === value) {\n                    found = true\n                    break;\n                }\n            }\n            \n            if (found) ret = '[Circular]'\n            else seen.push(value)\n        }\n        return ret;\n    };\n}\n\n//@ sourceURL=/node_modules/tape/lib/results.js"
));

require.define("/node_modules/tape/node_modules/jsonify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/package.json"
));

require.define("/node_modules/tape/node_modules/jsonify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/index.js"
));

require.define("/node_modules/tape/node_modules/jsonify/lib/parse.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/lib/parse.js"
));

require.define("/node_modules/tape/node_modules/jsonify/lib/stringify.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n\n//@ sourceURL=/node_modules/tape/node_modules/jsonify/lib/stringify.js"
));

require.define("/node_modules/tape/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/tape/node_modules/through/package.json"
));

require.define("/node_modules/tape/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data == null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/tape/node_modules/through/index.js"
));

require.define("/www/js/app.js",Function(['require','module','exports','__dirname','__filename','process','global'],"$(function() {\n  var coax = require(\"coax\"),\n    test = require(\"tape\");\n\n  var syncGateway = \"http://localhost:4984/test\"\n      testServer = coax(\"http://lite.couchbase./\"),\n      testDb = testServer(\"testdb\"),\n      syncCopy = testServer(\"testcopy\");\n\n\n  function syncUntilIdle(server, repl, cb) {\n    server.post(\"_replicate\", repl, function(err, sync) {\n      var pollStatus = setInterval(function() {\n        server.get(\"_active_tasks\", function(err, ok) {\n          var task;\n          for (var i = ok.length - 1; i >= 0; i--) {\n            if (ok[i].task == sync.session_id) {\n              task = ok[i];\n            }\n          };\n          if (task.status == \"Idle\") {\n            clearInterval(pollStatus);\n            cb(false, task)\n          }\n        })\n      },200);\n    })\n  };\n\n  test(\"couchbase lite is reachable\", function(t) {\n    console.log(\"tappin\", t)\n    testServer.get(function(err, info) {\n      t.ok(!err)\n      t.equal(info.couchdb, \"Welcome\")\n      t.end()\n    });\n  });\n\n  test(\"create database for sync\", function(t) {\n    // testDb.del(function(err, ok) {\n    //   if (err) {\n    //     t.equal(err.status, 404)\n    //   }\n      testDb.put(function(err, ok) {\n        if (err) {\n          t.equal(err.error, \"file_exists\")\n        }\n        t.end()\n      });\n    // })\n\n  });\n\n  test(\"load data\", function(t) {\n    var docs = [];\n    for (var i = 35; i >= 0; i--) {\n      docs.push({_id:i.toString(36), i:i});\n    };\n    testDb.post(\"_bulk_docs\", {docs:docs}, function(err, ok) {\n      console.log(\"_bulk_docs\", err, ok)\n      t.end()\n    });\n  });\n\n  test(\"sync to sync_gateway\", function(t) {\n    syncUntilIdle(testServer,{\n      source : \"testdb\",\n      target : syncGateway,\n      continuous : true\n    }, function(err, ok) {\n      t.end();\n    })\n  })\n\n  test(\"create empty database for copying\", function(t) {\n    // testDb.del(function(err, ok) {\n    //   if (err) {\n    //     t.equal(err.status, 404)\n    //   }\n      syncCopy.put(function(err, ok) {\n        if (err) {\n          t.equal(err.error, \"file_exists\")\n        }\n        t.end()\n      });\n    // })\n\n  });\n\n\n  test(\"sync from sync_gateway\", function(t) {\n    syncUntilIdle(testServer,{\n      source : syncGateway,\n      target : \"testcopy\",\n      continuous : true\n    }, function(err, ok) {\n      t.end();\n    })\n  })\n\n  test(\"verify data\", function(t) {\n    syncCopy.get(\"_all_docs\", function(err, data) {\n      console.log(\"_all_docs\", data);\n      t.end()\n    })\n  })\n\n});\n\n//@ sourceURL=/www/js/app.js"
));
require("/www/js/app.js");
})();
